---
layout: post_layout
title: 实效Go编程简析
time: 2017年6月2日 星期五
location: 北京
pulished: true
---

[Effective](https://go-zh.org/doc/effective_go.html)是关于如何写出高效Go程序的文档。


<!--break-->

#### **分号**

------

Go中的分号不在源码中出现，由词法分析器自动添加。当然If, For中自己写的。
规则是这样的：若在新行前的最后一个标记为标识符（包括 int 和 float64 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一
```
break continue fallthrough return ++ -- ) }

so:

if i < f()  // 错！
{           // 该行行首会被增加一个分号
	g()
}

```

#### **重新声明与重复赋值**

-----


Go中的短声明 := 的使用。

```
f, err := os.Open(name)

(some other code...)

d, err := f.Stat()

```
在上述的代码段中，err 在第一条语句中被声明，在第二次被**重新赋值**。

以声明的变量v可以再次出现在 := 有几个条件：

> * 本次声明和已声明的err处于同一作用域。
> * 类型与之前的类型相应。
> * 在此次声明中至少有一个新声明的变量，如d.

#### **For与Switch**

-----

注意，此处和C语言中的Goto不一样，标识符只能放在For或者Switch外面。
中间不能有其他语句，否则会报错。
执行效果是跳出当前的For或者Switch语句块，本次不会再重复进入。

如下所示，Here1,Here2分别为for和Switch工作，互不影响。
```
//第一段代码
Here1:
	for v := a[0]; v < 5; v++ {
		fmt.Println("for comming", v)
		if v == 3 {
			fmt.Printf("v==2 %+v \n", a)
			break Here1
		}
	Here2:
		switch {
		case m == 1:
			fmt.Printf("%+v \n", a)
			m = 2
			break Here2
		case m == 2:
			fmt.Printf("we get 2")
		}
		fmt.Printf("end : %+v \n", a)
	}
	return
```

switch还存在一个利用断言，动态判断接口类型的语法，如下

```
//第二段代码

	var t interface{}
	t = 8888
	switch v := t.(type) {
	default:
		fmt.Printf("unexpected type %T \n", t) // %T 输出 t 是什么类型
	case bool:
		fmt.Printf("boolean %t\n", t) // t 是 bool 类型
	case int:
		fmt.Printf("integer %d\n", t) // t 是 int 类型
		fmt.Printf("integer %d\n", v) // t 是 int 类型
	case *bool:
		fmt.Printf("pointer to boolean %t\n", *v) // t 是 *bool 类型
	case *int:
		fmt.Printf("pointer to integer %d\n", *v) // t 是 *int 类型
	}

```


> * 可命名结果形参
> * 未完待续
