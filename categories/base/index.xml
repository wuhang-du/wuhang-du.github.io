<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Base on Diamondu</title>
    <link>https://wuhang-du.github.io/categories/base/</link>
    <description>Recent content in Base on Diamondu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 May 2020 08:36:54 +0000</lastBuildDate>
    
	<atom:link href="https://wuhang-du.github.io/categories/base/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>tcpdump的高级用法</title>
      <link>https://wuhang-du.github.io/post/2020-5-1-tcpdump%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 01 May 2020 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2020-5-1-tcpdump%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid>
      <description>tcpdump是linux平台的，基于bpf的抓包工具。
比较常见的用法是： tcpdump -i eth1 tcp port 80
前几天在工作中遇到一个问题：线上的redis库，因为HGET命令中包含特殊字符报错。
不能确定是哪个模块引入的问题。
问题描述： tcp 7700 端口接收外部的查询命令, 同时包含多个redis命令字。 当前：只有 HGET 命令字有问题，且出错的字符串多是 a 域名。  抓全部的包去找有问题的场景简直大海捞针，因此让我们见识下tcpdump的新魔法：
tcpdump -i any &#39;tcp port 7700 and (((ip[2:2] - ((ip[0]&amp;amp;0xf)&amp;lt;&amp;lt;2)) - ((tcp[12]&amp;amp;0xf0)&amp;gt;&amp;gt;2)) != 0) and (tcp[25] == 0x34) and (tcp[28] == 0x48) and (tcp[29] == 0x47) and (tcp[30] == 0x45) and (tcp[31] == 0x54)&#39; -nnn -vvv -w 49.7700.pcap ====基础知识： ip[2:2] 以2起，2个字节表示包长度 (ip[0]&amp;amp;0xf)&amp;lt;&amp;lt;2 第一个字节 前4bit是协议 后4bit 乘以4 是ip包头大小。 tcp[12]&amp;amp;0xf0&amp;gt;&amp;gt;2 高位4bit是长度 tcp[0-19]表示包头，自tcp 20个字节起是 payload.</description>
    </item>
    
    <item>
      <title>看SICP有感</title>
      <link>https://wuhang-du.github.io/post/2020-4-18-sicp/</link>
      <pubDate>Sat, 18 Apr 2020 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2020-4-18-sicp/</guid>
      <description>17年最早是开始读sicp的pdf.看文本的效果比较一般,不太好抓重点,再一个编程的经验比较缺乏.
19年11月份的时候,从b站看到了sicp的视频,看了一遍.
20年4月,再次出发.有感于大型的系统设计,基于此,再次观看sicp,以此博客记录观看过程的思考.
lec1a: Lisp概览
对一门通用语言的学习,需要关注的几个点: 1.基本的元素: +,-,*,/ 数字. 2.组合: conds,if 3.抽象的方式: define  lec2a: 高阶过程
抽象模式。举个简单的例子： 过程1：for(a= i-&amp;gt;j) sum(a) 过程2：for(a= i-&amp;gt;j) sum(a^2) for与sum就是共同的模式，即可以被抽象的地方。 编程语言一等公民的权力： 1.可以被变量命名 2.可以被当作过程参数传递。 3.可以被当作过程的返回值。 4.可以被数据结构包含。  lec2b: 复合数据
数据和函数之间本身没有严格的界限。 c = (cons a b) (car c) = a (cdr c) = b 可以认为是一个内存的结构体布局。 也可以认为一个闭包函数。  </description>
    </item>
    
    <item>
      <title>一致性hash算法</title>
      <link>https://wuhang-du.github.io/post/2018-3-20-%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 20 Mar 2018 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2018-3-20-%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</guid>
      <description>看资料，了解到一致性hash算法。
简单的写了一个demo, 测试之后，再去看其他人的算法，理解得更快一些。这是一个好的模式。
func main() { hash := make([]string, 8) mask := (1 &amp;lt;&amp;lt; 3) - 1 hash[2] = &amp;quot;server1&amp;quot; hash[5] = &amp;quot;server2&amp;quot; hash[7] = &amp;quot;server3&amp;quot; i := 50 index := 0 for i &amp;lt; 58 { i++ index = i &amp;amp; mask for { if hash[index] != &amp;quot;&amp;quot; { fmt.Println(&amp;quot;find server: &amp;quot;, hash[index]) break } index = (index + 1) &amp;amp; mask } } }  github上搜到一个golang版本的代码
本质上是一样的。实现上有一些不同。使用数组 找机器+存机器 会浪费空间。</description>
    </item>
    
    <item>
      <title>从一道dp算法题说起</title>
      <link>https://wuhang-du.github.io/post/2018-2-24-%E4%BB%8E%E4%B8%80%E9%81%93dp%E7%AE%97%E6%B3%95%E9%A2%98%E8%AF%B4%E8%B5%B7/</link>
      <pubDate>Sat, 24 Feb 2018 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2018-2-24-%E4%BB%8E%E4%B8%80%E9%81%93dp%E7%AE%97%E6%B3%95%E9%A2%98%E8%AF%B4%E8%B5%B7/</guid>
      <description>被这道leetcode题目516. Longest Palindromic Subsequence折腾良久，直到最后弄清楚它，才大呼奇妙。 算法与思维的神奇，大概就在此处。
这篇文章不错，可以作为入门。
1.题目分析
动态规划的关键就是得出状态与状态转移方程。
这道题我的第一个问题就是：没有想清楚，为什么它是一个二维的状态? 一维与二维的区别就在于状态之间的转换。 对于这道题而言，以一个字符为例，它可以通过左边增加字符或者右边增加字符，进入下一个状态. 由现有的状态有超过1种途径进入下一个状态。因为它是二（多）维的。  这道题的状态转移方程如下：
dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]) Initialization: dp[i][i] = 1  2.代码分析。
看到上面的状态转移方程，很容易就可以得到递归的办法。
func longestPalindromeSubseq(s string) int { return check([]byte(s)) } func check(s []byte) int { if s[0] == s[len(s)-1] { return 2 + check(s[1:len(s)-1]) }else { a := check(s[0:len(s)-1]) b := check(s[1:len(s)]) if b &amp;gt; a { a = b } return a } } 这样是过不了的。加上缓存，去掉重复的计算，accepted.</description>
    </item>
    
    <item>
      <title>Count Bits</title>
      <link>https://wuhang-du.github.io/post/2018-1-22-count-bits/</link>
      <pubDate>Mon, 22 Jan 2018 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2018-1-22-count-bits/</guid>
      <description>在刷算法的时候遇到了好几个有趣的计算一个数中，bit位为1的个数。
1.直接计算
直接计算移位计算1.需要注意的是，输入参数。int 与 uint 的移位策略是不一样的。 int count(uint64 x) { int count = 0; for(; x; x&amp;gt;&amp;gt;1) ++count; return count; }  2.一点点小技巧
利用（8）1000 - 1 = （7）0111. int count(uint64 x) { int count = 0; for (; x; ++count) x&amp;amp;=x-1; return count; }  3.分治
const uint64 m1 = 0x5555555555555555; const uint64 m2 = 0x3333333333333333; const uint64 m4 = 0x0f0f0f0f0f0f0f0f; const uint64 m8 = 0x00ff00ff00ff00ff; const uint64 m16 = 0x0000ffff0000ffff; const uint64 m32 = 0x00000000ffffffff; int count(uint64 x) { x = (x &amp;amp; m1 ) + ((x &amp;gt;&amp;gt; 1) &amp;amp; m1 ); x = (x &amp;amp; m2 ) + ((x &amp;gt;&amp;gt; 2) &amp;amp; m2 ); x = (x &amp;amp; m4 ) + ((x &amp;gt;&amp;gt; 4) &amp;amp; m4 ); x = (x &amp;amp; m8 ) + ((x &amp;gt;&amp;gt; 8) &amp;amp; m8 ); x = (x &amp;amp; m16) + ((x &amp;gt;&amp;gt; 16) &amp;amp; m16); x = (x &amp;amp; m32) + ((x &amp;gt;&amp;gt; 32) &amp;amp; m32); return x; }  4.</description>
    </item>
    
  </channel>
</rss>