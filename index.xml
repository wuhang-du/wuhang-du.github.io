<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Diamondu</title>
    <link>https://wuhang-du.github.io/</link>
    <description>Recent content on Diamondu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Aug 2017 08:36:54 +0000</lastBuildDate>
    
	<atom:link href="https://wuhang-du.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go与Nodejs性能简单对比</title>
      <link>https://wuhang-du.github.io/post/2017-08-14-go%E4%B8%8Enodejs%E6%80%A7%E8%83%BD%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Mon, 14 Aug 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-08-14-go%E4%B8%8Enodejs%E6%80%A7%E8%83%BD%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</guid>
      <description>背景 大半夜忽然想起来，之前同事提到的Go与Nodejs的性能比较，具体的数据差距很大。当时没有太在意，后来慢慢对Go了解了一些。从原理上来说
Nodejs采用的是Reactor这种结构，与Nginx类似，一个连接就是一个数据结构，通过Epoll等来实现IO异步。 Go底层也是Reactor，每一个Go程就可以认为是单个数据结构，调度是由Go本身来提供的。  同事的测试数据记不清了，我的观点是Go和Nodejs应该是一个数量级的，但是Go默认是多核，而Nodejs天生就是单核，所以造成了巨大的差异。因此初步的想法就是验证多核和单核的影响。
过程 centos7 ，虚拟机，cpu 4核。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;net/http&amp;quot; ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello World&amp;quot;) } func main() { runtime.GOMAXPROCS(1) //关键点 http.HandleFunc(&amp;quot;/&amp;quot;, handler) http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil) }  var http = require(&amp;quot;http&amp;quot;); http.createServer(function(request, response) { response.end(&amp;quot;hello World&amp;quot;); }).listen(8888,&amp;quot;0.0.0.0&amp;quot;);  测试使用Wrk，Nodejs使用pm2。
wrk -t12 -c400 -d30s http://localhost:8080 pm2 start app.js -i 0 --name &amp;quot;api&amp;quot;  Running 30s test @ http://localhost:8888 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 23.</description>
    </item>
    
    <item>
      <title>微服务入门之Nodejs-Seneca</title>
      <link>https://wuhang-du.github.io/post/2017-08-13-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8Bnodejs-seneca/</link>
      <pubDate>Sun, 13 Aug 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-08-13-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8Bnodejs-seneca/</guid>
      <description>项目上可能会用到微服务，因此以Seneca构建微服务为例，记录一下自己的一些理解。主要内容以get-started为基础。
Seneca is a microservices toolkit for Node.js  what is Senaca 业务逻辑之外的一切都可以用微服务包装。通过解耦来让业务系统可以很容易的创建和改变。
Senaca有以下几个属性：
1. 模式匹配。 2. 隐藏服务间通信细节。 3. 组件化。通过插件组合成为微服务。  问题：多种通信协议的支持是怎么做的，或者是怎么配置的？Seneca内置有http，tcp等，消息队列等应该需要加新的微服务。搜索了一下，npm有seneca-queue。
在一个进程内 通过seneca.add()增加模式，以及对应的处理函数。通过seneca.act()来触发该模式，以供add中添加的处理函数在逻辑之后调用act的回掉函数。
问题：如果是远程调用，回调函数会被传递过去吗？ 答:不会，把模式msg发过去，远程的微服务将处理的结果传递回来，再供回调函数处理。可以看出，一个模式，加一个 处理逻辑就是一个服务，区别只是这个服务的位置。远端需要类似rpc。  模式匹配 在seneca中，“The more specific pattern always wins. In other words, the pattern with the highest number of matching attributes has precedence”。“If the patterns have the same number of properties, they are matched in alphabetical order.”
举例说明：需要匹配的pattern信息是&#39;a:1, b:2&#39;： 如果微服务提供 &#39;a:1&#39;，&#39;a:1, b:2&#39;,这两个同时满足，则匹配more specific，即第二个。 字母顺序没太懂。感觉是在说精确匹配，不知道为什么要专门提这个。  因此，新的更具体的服务，只需要更加具体的模式，就可以在不影响原有功能的情况下扩展。</description>
    </item>
    
    <item>
      <title>技能的反面</title>
      <link>https://wuhang-du.github.io/post/2017-08-12-%E6%8A%80%E8%83%BD%E7%9A%84%E5%8F%8D%E9%9D%A2/</link>
      <pubDate>Sat, 12 Aug 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-08-12-%E6%8A%80%E8%83%BD%E7%9A%84%E5%8F%8D%E9%9D%A2/</guid>
      <description>介绍 这篇博客是技能的反面 - 魔方和模仿以及The Psychology of Cross Country的读后感。
这些文章通过对学习本身的一些思考，让我们能够更加高效的去获取技能。我想做的就是去获取这些文章后面的“渔”，而不是简简单单地得到“鱼”。
整篇文章我将以游泳为例来说明，就像Bill Buxton以骑马为例一样。
技能与解决问题有什么区别 技能的定义就是：即Automatic,可以无意识的自动去做某件事。我现在可以浮在水面而不用去考虑我是怎么实现的。
解决问题：即Attentive Behaviour，是说做某件事的时候需要考虑很多东西。例如我最近在学习自由泳的打腿与划手的配合，在游的过程中，既要考虑腿的节奏，又需要考虑手的动作。
但是浮在水面却不是我需要考虑的，因为这已经是我的一个技能，skilled。
练习的魔力 在获取某件技能的时候，一条最重要的法则就是：不断的练习，&amp;rdquo;do it over and over and over again, then do it some more&amp;rdquo;，直到它变成一项技能。
干扰 就像我自己提到的大腿的手脚配合，单独的打腿与单独的划手我是可以完成的，但是同时做这两件事情，这两件事就会互相干扰。
总结 为了获取某项技能，把某件事情由解决问题变成一项技能，一共有以下几点：
 1.练习，不断的练习。
 2.预案。预案的含义是对于突发情况做出准备计划。这样，当突发情况出现时，不至于手足无措。同时，能够减少精力的分散，这样对整个大局的影响最小。
 3.速度。只需要降低约10%的速度，就可以解决在过程中遇到的问题，以便更加平稳的进入下一个阶段。换言之，如果，操之过急，速度增加10%，那么就会面临只能解决一半问题的窘境。
  应用 这几天结合我的学习，发现还是很有用的。文中提到的论文，我前后一共阅读了3遍。
分析一下，读懂文章，需要
 1.理解单词的意思， 2.理解语法， 3.思考作者的思想
 这几个技能。然而这些都不是我的技能。第一遍的时候，这几个点互相影响，同时追求速度，因此无法读懂内容。第二遍的时候，无意运用了预案和速度的观点，延长了思考作者思想的时间即读文章的时间，在过程中查词，理解语法，虽然速度慢，但是效果很好，花了30分钟左右，但是真的读懂了。第三遍即不断的练习，以便有更深刻的理解。
如果是听英语呢？ 首先就是要多听，多读，即观点1。第二在听和读的过程中遇到不会的单词，句子怎么办，第三就是心别急，查完单词，理解完语法。也就是说把单词的含义以及语法Automatic之后，继续进入下一个阶段的问题解决。
如果是敲代码呢？ 首先就是要多写，多做。第二就是如果在过程中遇到突发状况如何处理？应该停下来，解决问题，而不是改一下一遍又一遍的重复测试。第三就是要心别急，拉长解决问题的时间，把当前的问题解决掉，再进入下一个阶段。另外的一个体会就是阶段，如果不懂一个语言的语法，也就无法进行架构的设计。因为在实现的过程中，一直在解决各种神奇的小问题。因此对于底层的问题，先解决掉，变成技能之后，再进入高层次的问题解决。
如果是游泳呢？ 首先就是要多练习，分别练习打腿和转身和手的动作。预案就是当同时进行，互相影响的时候，停下来继续练单个动作。速度的观点就是游慢点。哈哈。</description>
    </item>
    
    <item>
      <title>我的Git之旅</title>
      <link>https://wuhang-du.github.io/post/2017-07-26-%E6%88%91%E7%9A%84git%E4%B9%8B%E6%97%85/</link>
      <pubDate>Wed, 26 Jul 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-07-26-%E6%88%91%E7%9A%84git%E4%B9%8B%E6%97%85/</guid>
      <description>echo &amp;quot;你好, Git!&amp;quot;;  git remote 命令，定义远端的主机。这个远端，可以是另外一台机器，最常用的就是github
使用git remote -v 就可以显示本地当前仓库的远程主机。
 git remote add [name] [url] example: git remote add origin https://github.com/wuhang-du/leetcode 远端仓库在远端 example: git remote add origin1 ../git-test 远端仓库在本地  git merge 命令，即合并，主要提一下 &amp;ndash;no-ff的使用。
示例当前的分支是：master。develop分支以master分支作为基准分支，增加了新的内容。
调用操作之后使用tig 查看当前的状态：
git merge develop 2017-07-26 11:32 du [develop] [master] Merge branch &#39;develop&#39; 结果：master指向了develop,变成了新的master.此时master与 develop 状态相同。 git merge develop --no-ff 2017-07-26 11:32 du M [master] Merge branch &#39;develop&#39; | 2017-07-26 11:31 du | o [develop] test | 2017-07-26 11:28 du M update 结果：master与develop合并，生成了新的master,此状态超前 develop 一次。  git pull 是从远程主机拉取变化，并更新本地的命令。</description>
    </item>
    
    <item>
      <title>Mongo锁机制与索引的理解</title>
      <link>https://wuhang-du.github.io/post/2017-06-28-mongo-lock/</link>
      <pubDate>Wed, 28 Jun 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-06-28-mongo-lock/</guid>
      <description>&lt;p&gt;对Mongo锁机制以及索引的一些分析与理解&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go: Context 理解</title>
      <link>https://wuhang-du.github.io/post/2017-06-25-gocontext%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 25 Jun 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-06-25-gocontext%E7%90%86%E8%A7%A3/</guid>
      <description>在看proxy的时候，看到了context这个package.
 source 1: Package context
Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context &amp;gt; * 对于，访问本服务器的Incoming 请求应该建立一个Context. &amp;gt; * 对于，从本服务器访问其他服务器的Outgoing 请求应该接收Context.  下面的链接中包含了创建一个context的代码。
source 2: Go Concurrency Patterns: Context
WithCancel WithDeadline WithTimeout WithValue 以上函数根据不同的含义，分别返回parent Context的child Context。 package main import ( &amp;quot;context&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { d := time.Now().Add(50 * time.Millisecond) ctx, cancel := context.WithDeadline(context.Background(), d) // Even though ctx will be expired, it is good practice to call its // cancelation function in any case.</description>
    </item>
    
    <item>
      <title>从零开始用Go写代理</title>
      <link>https://wuhang-du.github.io/post/2017-06-15-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%94%A8go%E5%86%99%E4%BB%A3%E7%90%86/</link>
      <pubDate>Thu, 15 Jun 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-06-15-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%94%A8go%E5%86%99%E4%BB%A3%E7%90%86/</guid>
      <description>学习一门语言还是需要理论与实践相结合的，于是决定开始利用Go语言实现Proxy的功能。
 1.需求分析   实现http协议的代理。 高性能，高并发。   大概写一个排期吧
6-16 &amp;ndash; 6-23 把基本的架子搭起来，实现访问代理，代理返回后台的数据。
6-23 &amp;ndash; 6-30 查看理论，进一步分析现有的功能，对第一期的代码重构。
2.理论分析 想到了自己比较常用的几款proxy。查了查，简单分析下：
 Nginx, Haproxy 反向代理：  Client &amp;lt;&amp;ndash; &amp;ndash;&amp;gt; Nginx, Haproxy &amp;lt;&amp;ndash; &amp;ndash;&amp;gt; Server
 ShadowSocks  Client &amp;lt;&amp;ndash; &amp;ndash;&amp;gt; (local ss client) &amp;lt;&amp;ndash; &amp;ndash;&amp;gt; (remote ss server) &amp;lt;&amp;ndash; &amp;ndash;&amp;gt; server
我的目标是实现诸如Nginx与Haproxy的反向代理。
从配置文件中可以看出，将请求导入到代理之后，根据host名以及url来做导向。
刚才想到一点，可以不解析body，根据head就可以确定导向。
3. 实践部分 6.16 完成了初步的框架。一个请求可以转接。
有一个问题： 问题背景： server: 监听8081端口，有请求时返回字符串 &amp;quot;hello&amp;quot; proxy: 监听8080端口，外界的请求到达时，启动go程，go程内去构建新的请求，去8081访问，并写结果。 client: 采用wrk模式，并发1000个。 报错： go程内client.do函数： error: Get http://192.</description>
    </item>
    
    <item>
      <title>Go内存泄漏分析及解决办法</title>
      <link>https://wuhang-du.github.io/post/2017-06-05-go%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Mon, 05 Jun 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-06-05-go%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>文章将展示常见的Goroutine leak以及对应的解决办法。
 Talk is cheap, I will show you the code.
各种泄露的展示 第一段代码来源
type Writer struct { queue chan []byte } func NewWriter() *Writer { w := &amp;amp;Writer{ queue: make(chan []byte, 10), } go w.process() return w } func (w *Writer) Write(message []byte) { w.queue &amp;lt;- message } func (w *Writer) process() { for { message := &amp;lt;- w.queue // do something with message } } func main() { fmt.</description>
    </item>
    
    <item>
      <title>Go：使用channel共享内存</title>
      <link>https://wuhang-du.github.io/post/2017-06-03-go%E4%BD%BF%E7%94%A8channel%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link>
      <pubDate>Sat, 03 Jun 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-06-03-go%E4%BD%BF%E7%94%A8channel%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid>
      <description>Go的口号：不要通过共享内存来通信，而应通过通信来共享内存
 Talk is cheap, I will show you the code.
func main() { c1 := make(chan int) quit := make(chan int) test := 0 a := [...]int{1, 2, 3} for _, v := range a { go func(v int) { for { select { case my := &amp;lt;-c1: my++ fmt.Printf(&amp;quot;id: %d now count is %d \n&amp;quot;, v, my) c1 &amp;lt;- my case &amp;lt;-quit: fmt.Printf(&amp;quot;id: %d return \n&amp;quot;, v) return } } }(v) } c1 &amp;lt;- test time.</description>
    </item>
    
    <item>
      <title>实效Go编程简析</title>
      <link>https://wuhang-du.github.io/post/2017-06-02-%E5%AE%9E%E6%95%88go%E7%BC%96%E7%A8%8B%E7%AE%80%E6%9E%90/</link>
      <pubDate>Fri, 02 Jun 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-06-02-%E5%AE%9E%E6%95%88go%E7%BC%96%E7%A8%8B%E7%AE%80%E6%9E%90/</guid>
      <description>Effective Go是关于如何写出高效Go程序的文档。
 分号 Go中的分号不在源码中出现，由词法分析器自动添加。当然If, For中自己写的。 规则是这样的：若在新行前的最后一个标记为标识符（包括 int 和 float64 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一
break continue fallthrough return ++ -- ) } so: if i &amp;lt; f() // 错！ { // 该行行首会被增加一个分号 g() }  重新声明与重复赋值 Go中的短声明 := 的使用。
f, err := os.Open(name) (some other code...) d, err := f.Stat()  在上述的代码段中，err 在第一条语句中被声明，在第二次被重新赋值。
以声明的变量v可以再次出现在 := 有几个条件：
  本次声明和已声明的err处于同一作用域。 类型与之前的类型相应。 在此次声明中至少有一个新声明的变量，如d.   For与Switch 注意，此处和C语言中的Goto不一样，标识符只能放在For或者Switch外面。 中间不能有其他语句，否则会报错。 执行效果是跳出当前的For或者Switch语句块，本次不会再重复进入。
如下所示，Here1,Here2分别为for和Switch工作，互不影响。
//第一段代码 Here1: for v := a[0]; v &amp;lt; 5; v++ { fmt.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://wuhang-du.github.io/about/</link>
      <pubDate>Fri, 12 May 2017 08:36:54 -0700</pubDate>
      
      <guid>https://wuhang-du.github.io/about/</guid>
      <description>喜欢C语言，喜欢Unix以及Unix的文化
正在学习Go.
希望自己能越来越厉害
2017-5-12 0:38 于北京</description>
    </item>
    
    <item>
      <title>wrk压测工具简析</title>
      <link>https://wuhang-du.github.io/post/2017-05-12-start-wrk/</link>
      <pubDate>Fri, 12 May 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-05-12-start-wrk/</guid>
      <description>Wrk是一款高性能的基于Linux平台的压测工具。
 1.基础功能 命令是：
wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html -t : 线程数 -c : http连接总数。 -d : 测试时长。 -s : lua脚本参数  2.简单分析 wrk主要是
  基于redis的ae模块, 提供异步框架。 nginx的httpparser, 提供http的请求解析。 lua脚本，利用Lua的创建更复杂的测试用例。   3.简单使用 Http压测工具wrk使用指南
wrk &amp;ndash; 小巧轻盈的 http 性能测试工具.</description>
    </item>
    
    <item>
      <title>开始技术博客</title>
      <link>https://wuhang-du.github.io/post/2017-05-11-first/</link>
      <pubDate>Mon, 01 May 2017 08:36:54 +0000</pubDate>
      
      <guid>https://wuhang-du.github.io/post/2017-05-11-first/</guid>
      <description>第一版：2017-5-1
我的第一篇 github 博客, 本博客使用 jekyll + bootstrap 搭建!
感谢 github 提供的 Github Pages 功能!
第二版：2017-7-27
使用Hugo搭建，基于hyde
借鉴了rakyll的css.
独立添加了tags的功能。
echo &amp;quot;你好, Github Pages!&amp;quot;;  </description>
    </item>
    
  </channel>
</rss>